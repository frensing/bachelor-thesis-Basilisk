\chapter{Approach}
\label{ch:approach}
%%%%%%%%%%%%%%%%%%%%%%%
% - description of the designed system
% - analysis and review of the current software architecture
% - gerne in die Tiefe gehen
%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we give an overview of the current software architecture on which the Basilisk platform is build.
\\

The purpose of the Basilisk platform is to provide an easy way to continuously perform benchmarks on \tsp{}.
\tsp{} are often developed in teams who collaborate in Git repositories.
Releases of those \tsp{} are then published on GitHub or as a Docker image on Docker Hub.
Basilisk will offer the possibility to automatically benchmark a new \tsp{} release.

Benchmarks are also relevant during the development process.
An benchmark performed automatically for \eg{} a new pull request is a good way to estimate if a newly developed feature will impact the performance of the \ts{} before the changes are merged.

On the Basilisk platform a user can register a \ts{} for a continuous benchmark by setting up a hook to the repository on GitHub or a docker image from Docker Hub containing the \ts{}, which will then be observed by Basilisk.
If there is a new release of the \ts{}, Basilisk will fetch and build the new docker container to perform a benchmark.
The measured results of the benchmark will be stored in a database and are then available through the web frontend to review.
\\

The basic architecture pattern of the Basilisk platform is the microservice architecture (see chapter \ref{sec:microservice_architecture} for a short description). 
This means that the platform is divided into multiple services on which the workload and the different tasks are divided.
The services can be run on different hardware systems and they interact with each other via a message queue system.
\\

Figure \ref{fig:basilisk_high_level_design} gives an overview of the microservice architecture for the Basilisk platform and the most important messages send between the services.
\todo{graphic}
\begin{figure}[tbph]
	\centering
	\textbf{TODO: better graphic}
	%\includegraphics[width=1.1\textwidth]{figures/basilisk_high_level_design.pdf}
	\caption{High level design of the Basilisk framework}
	\label{fig:basilisk_high_level_design}
\end{figure}
\\

\section{Main Services}
\label{sec:main_services}
The next sections explain the three main services, namely \acl{hcs} (\ref{sec:hooks_checking_service}), \acl{jms} (\ref{sec:jobs_managing_service}), and \acl{tbs} (\ref{sec:ts_benchmarking_service}).

This explanation follows the flow of actions that happen while configuring a continuous benchmark and the actions that happen when a benchmark is initiated.


\subsection{\acl{hcs}}
\label{sec:hooks_checking_service}
The main task of the \ac{hcs} is to observe Github and Docker Hub repositories for new releases or changes.

When a user wants to set up a new continuous benchmark, the \ac{hcs} needs to be informed which repository (GitHub or Docker Hub) needs to be observed for changes.
This happens through API calls from the frontend to the hooks checking service providing the repository name and owner.
The \ac{hcs} will then create a hook for the repository to get notice about changes.
A hook is in general a piece of code or software that attaches itself to a software component to intercept messages and react to those messages, \eg, with function calls.
In the case of the \ac{hcs} the hooks can be seen as bookmarks for the repositories to regularly check for new versions and releases.
Each hook stores the latest known version of an repository to easily compare for new versions.

When the \ac{hcs} notices a new release for a repository it observes, it updates the corresponding hook to the newest version.
Then it sends a message about the new version to the \aclp{jrq} from which the \acl{jms} retrieves the message.

\subsubsection{API}
\label{sec:hooks_api}
The \ac{hcs} is controlled over a REST API, which is also used by the frontend.
The most important endpoints are for adding links repositories.
Also the continuous checking of repositories can be started or stopped over the API.


\subsection{\acl{jms}}
\label{sec:jobs_managing_service}
The \acf{jms} processes the requests coming from the web-frontend, checks if the Hooks Checking Service has found a new version for a benchmark and creates jobs for new benchmarks.



%\subsubsection{API}
%\label{sec:jobs_api}


\subsection{\acl{tbs}}
\label{sec:ts_benchmarking_service}
Lastly the \ac{tbs} executes the benchmarks given to it and saves the results to a database.

%\subsubsection{API}
%\label{sec:benchmarking_api}


\section{Message Queue System}
\label{sec:message_queue}
The messages send between the services are transmitted via the RabbitMQ (\ref{sec:rabbitmq}) message broker.

There are two groups of queues.
The first group consists of the \aclp{jrq}
\todo{continue}

\todo{why queues to JMS when Repo added etc?}



\section{Programming Language and Frameworks}
\label{sec:prog_lang_and_framework}
All services are implemented with Java and are using the Spring Boot framework.

The package structure used for the service implementation is similar in all three services.
It is strongly influence through the use of the Spring Boot framework.
The Spring and Spring Boot framework are shortly described in chapter \ref{sec:spring}.
\\





\section{Frontend}
\label{sec:frontend}