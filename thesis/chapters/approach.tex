\chapter{Approach}
\label{ch:approach}
%%%%%%%%%%%%%%%%%%%%%%%
% - description of the designed system
% - analysis and review of the current software architecture
% - gerne in die Tiefe gehen
%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we give an overview to the design of the Basilisk platform.
We will explain the different processes used in the platform in section \ref{sec:main_services}.
In section \ref{sec:architecture_review} we will analyze and review the current software architecture and implementation status of the Basilisk platform.
\\

\todo[inline]{mehr roter Faden, Verbindung zw den genannten Punkten}
The purpose of the Basilisk platform is to provide an easy way to continuously perform benchmarks on \tsp{}.
Triplestores are often developed in teams who collaborate in Git repositories.
Releases of those \tsp{} are then published on \gh{} or as a Docker image on \dockh{}.
The idea is that the Basilisk platform will automatically check for a new release of a registered \ts{} repository and will then perform benchmarks on this release.

Benchmarks are also relevant during the development process.
A benchmark performed automatically, for example, when a new pull request is added, is a good way to estimate if a newly developed feature will impact the performance of the \ts{} before the changes are merged.

On the Basilisk platform, a user can register a \ts{} for a continuous benchmark by setting up a hook to the repository on \gh{} or \dockh{}.
The repository will then be observed by the Basilisk platform.
If there is a new release of the \ts{}, Basilisk will generate a new benchmark job.
This benchmark job will then be executed by fetching and building a new Docker container, containing the newest release of the \ts{}.
On this container the benchmark will be performed.
The measured results of the benchmark will be stored in a \ts{} and are then available through the web frontend for review.
\\

The basic architecture pattern of the Basilisk platform is the microservice architecture (see chapter \ref{sec:microservice_architecture} for a short description). 
This means that the platform is divided into multiple services on which the workload and the different tasks are divided.
The services can be run on different hardware systems and they interact with each other via the RabbitMQ (\ref{sec:rabbitmq}) message queue system.
\\

\section{Programming Language and Frameworks}
\label{sec:prog_lang_and_framework}
All services of the Basilisk platform are implemented with Java and are using the Spring Boot framework.
The services use Java version 17 and Spring Boot version 2.6.6.

The package structure used for implementing the services is similar in all three services.
It is strongly influenced by the structure recommended for the Spring Boot framework.


%%%%%% MAIN SERVICES
\input{chapters/approach/main_services.tex}



\section{Basilisk Frontend}
\label{sec:basilisk_frontend}
The Basilisk platform can be extended with a web frontend.
The frontend is implemented using JavaScript and the JavaScript framework Vue.js.

The idea is that the frontend functions as a graphical interface for the REST APIs of the three services explained in section \ref{sec:main_services}.
The user can set up new repositories, \tsp{} and datasets.
Further, the user can request information about current benchmark jobs, abort or remove pending jobs.
Lastly, the frontend can request and visualize the benchmarking results stored in the \acl{jsts}.



%%%%%% ARCHITECTURE REVIEW
\input{chapters/approach/architecture_review.tex}



